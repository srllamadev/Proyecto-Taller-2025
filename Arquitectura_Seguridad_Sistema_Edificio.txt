ARQUITECTURA DE SEGURIDAD PARA SISTEMAS DE ADMINISTRACIÓN DE EDIFICIOS:
UN ENFOQUE INTEGRAL CON SEGMENTACIÓN DE RED

Sistema de Administración de Edificio - Análisis de Seguridad

Autor: Equipo de Desarrollo
Fecha: 11 de septiembre de 2025
Institución: Proyecto Sistema Edificio 2025A

================================================================================

RESUMEN EJECUTIVO

Este documento presenta un análisis exhaustivo de la arquitectura de seguridad implementada en el Sistema de Administración de Edificios, enfocándose en la segmentación de red, controles de acceso y medidas de protección de datos. El sistema utiliza una arquitectura de tres capas con separación lógica de responsabilidades y múltiples niveles de seguridad para garantizar la integridad, confidencialidad y disponibilidad de la información crítica del edificio.

Palabras clave: segmentación de red, arquitectura de seguridad, administración de edificios, Flask, SQLite, protección de datos

================================================================================

1. INTRODUCCIÓN

1.1 Contexto del Sistema

El Sistema de Administración de Edificios representa una solución integral para la gestión de propiedades residenciales, integrando funcionalidades de administración de departamentos, inquilinos, empleados y pagos. La arquitectura del sistema se fundamenta en principios de seguridad por diseño (Security by Design) y defensa en profundidad (Defense in Depth), implementando múltiples capas de protección para salvaguardar la información sensible (NIST, 2018).

1.2 Objetivos de Seguridad

Los objetivos principales de la arquitectura de seguridad incluyen:
- Protección de datos personales y financieros de inquilinos
- Segregación de responsabilidades entre componentes del sistema
- Implementación de controles de acceso granulares
- Monitoreo y auditoría de actividades del sistema
- Resiliencia ante amenazas internas y externas

================================================================================

2. ARQUITECTURA GENERAL DEL SISTEMA

2.1 Modelo de Capas

El sistema implementa una arquitectura de tres capas claramente definidas:

┌─────────────────────────────────────────────────────────────┐
│                    CAPA DE PRESENTACIÓN                     │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   Frontend Web  │  │   Visualizador  │  │   Reportes   │ │
│  │   (HTML/CSS/JS) │  │   Base Datos    │  │   Análisis   │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                        [HTTPS/TLS 1.3]
                                │
┌─────────────────────────────────────────────────────────────┐
│                     CAPA DE APLICACIÓN                      │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  API REST       │  │  Autenticación  │  │  Validación  │ │
│  │  (Flask)        │  │  y Autorización │  │  de Datos    │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                        [Conexión Segura]
                                │
┌─────────────────────────────────────────────────────────────┐
│                      CAPA DE DATOS                          │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   Base Datos    │  │   Respaldos     │  │   Logs de    │ │
│  │   SQLite        │  │   Automáticos   │  │   Auditoría  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘

2.2 Principios de Diseño Seguro

La arquitectura se basa en los siguientes principios fundamentales:

a) Separación de Responsabilidades (Separation of Concerns):
   - Frontend maneja únicamente la presentación
   - Backend gestiona la lógica de negocio y validaciones
   - Base de datos almacena información con controles de integridad

b) Principio de Menor Privilegio (Principle of Least Privilege):
   - Cada componente tiene acceso únicamente a los recursos necesarios
   - Validaciones en múltiples niveles
   - Restricciones de acceso por funcionalidad

c) Defensa en Profundidad (Defense in Depth):
   - Múltiples capas de seguridad
   - Validación tanto en cliente como en servidor
   - Monitoreo continuo de actividades

================================================================================

3. SEGMENTACIÓN DE RED Y ARQUITECTURA DE SEGURIDAD

3.1 Diseño de Segmentación

La segmentación de red implementada sigue las mejores prácticas de la industria para sistemas de administración crítica:

┌─────────────────────────────────────────────────────────────┐
│                     INTERNET (RED PÚBLICA)                  │
└─────────────────────┬───────────────────────────────────────┘
                      │
              [Firewall Perimetral]
                      │
┌─────────────────────┴───────────────────────────────────────┐
│                  DMZ (ZONA DESMILITARIZADA)                 │
│  ┌─────────────────┐    ┌─────────────────┐                │
│  │  Proxy Reverso  │    │  Load Balancer  │                │
│  │  (NGINX/Apache) │    │                 │                │
│  └─────────────────┘    └─────────────────┘                │
└─────────────────────┬───────────────────────────────────────┘
                      │
              [Firewall Interno]
                      │
┌─────────────────────┴───────────────────────────────────────┐
│                  RED INTERNA (VLAN 100)                     │
│  ┌─────────────────┐    ┌─────────────────┐                │
│  │  Servidor Web   │    │  Servidor API   │                │
│  │  (Frontend)     │    │  (Flask)        │                │
│  │  Puerto: 8000   │    │  Puerto: 5000   │                │
│  └─────────────────┘    └─────────────────┘                │
└─────────────────────┬───────────────────────────────────────┘
                      │
              [Firewall Base Datos]
                      │
┌─────────────────────┴───────────────────────────────────────┐
│                 RED DE DATOS (VLAN 200)                     │
│  ┌─────────────────┐    ┌─────────────────┐                │
│  │  Base de Datos  │    │  Servidor       │                │
│  │  SQLite         │    │  Respaldos      │                │
│  │  Puerto: Local  │    │                 │                │
│  └─────────────────┘    └─────────────────┘                │
└─────────────────────────────────────────────────────────────┘

3.2 Configuración de VLANs

La segmentación se implementa mediante VLANs específicas:

- VLAN 100 (Red de Aplicación): 192.168.100.0/24
  * Servidores web y de aplicación
  * Acceso controlado desde DMZ
  * Monitoreo continuo de tráfico

- VLAN 200 (Red de Datos): 192.168.200.0/24
  * Servidores de base de datos
  * Acceso exclusivo desde VLAN 100
  * Cifrado de datos en reposo y en tránsito

- VLAN 300 (Red de Administración): 192.168.300.0/24
  * Herramientas de monitoreo
  * Acceso de administradores
  * Logs centralizados

3.3 Reglas de Firewall

Las reglas de firewall implementadas siguen el principio de "denegar todo, permitir específico":

Firewall Perimetral:
```
PERMIT tcp any -> DMZ:80,443 (HTTP/HTTPS)
PERMIT tcp admin_networks -> DMZ:22 (SSH Admin)
DENY all any -> any (Regla por defecto)
```

Firewall Interno:
```
PERMIT tcp DMZ -> VLAN100:5000 (API Flask)
PERMIT tcp DMZ -> VLAN100:8000 (Web Server)
PERMIT tcp VLAN100 -> VLAN200:3306 (Database)
DENY all any -> any (Regla por defecto)
```

Firewall Base de Datos:
```
PERMIT tcp VLAN100:app_servers -> VLAN200:db_port
PERMIT tcp VLAN300:backup_server -> VLAN200:backup_port
DENY all any -> any (Regla por defecto)
```

================================================================================

4. CONTROLES DE SEGURIDAD POR CAPA

4.1 Capa de Presentación

Controles de seguridad implementados:

a) Validación de Entrada del Cliente:
   - Validación JavaScript para datos de formularios
   - Sanitización de entradas antes del envío
   - Controles de longitud y formato de datos

b) Protección contra Ataques del Cliente:
   - Content Security Policy (CSP) headers
   - Protección contra XSS (Cross-Site Scripting)
   - Validación de tipos de contenido

c) Comunicación Segura:
   - Uso exclusivo de HTTPS/TLS 1.3
   - Verificación de certificados SSL
   - Implementación de HSTS (HTTP Strict Transport Security)

Ejemplo de implementación CSP:
```html
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; 
               script-src 'self' 'unsafe-inline' cdn.jsdelivr.net; 
               style-src 'self' 'unsafe-inline' cdn.jsdelivr.net;
               img-src 'self' data:;">
```

4.2 Capa de Aplicación

La capa de aplicación implementa múltiples controles de seguridad:

a) Autenticación y Autorización:
```python
# Ejemplo de middleware de autenticación
@app.before_request
def authenticate_request():
    if request.endpoint and request.endpoint.startswith('api/'):
        # Verificar token de autenticación
        auth_header = request.headers.get('Authorization')
        if not auth_header or not validate_token(auth_header):
            return jsonify({'error': 'Unauthorized'}), 401
```

b) Validación de Datos de Entrada:
```python
# Validación robusta de datos
def validate_departamento_data(data):
    if not isinstance(data.get('numero'), str) or len(data['numero']) > 10:
        raise ValidationError("Número de departamento inválido")
    
    if not isinstance(data.get('piso'), int) or data['piso'] < 1:
        raise ValidationError("Piso debe ser un número positivo")
    
    estados_validos = ['Ocupado', 'Libre', 'Mantenimiento']
    if data.get('estado') not in estados_validos:
        raise ValidationError("Estado inválido")
```

c) Protección contra Inyección SQL:
```python
# Uso de parámetros preparados
def get_departamento_by_id(dept_id):
    cursor.execute(
        "SELECT * FROM departamentos WHERE id = ?", 
        (dept_id,)
    )
    return cursor.fetchone()
```

d) Manejo Seguro de Errores:
```python
# Manejo de errores sin revelar información sensible
@app.errorhandler(500)
def handle_internal_error(error):
    # Log detallado para administradores
    app.logger.error(f"Error interno: {str(error)}")
    
    # Respuesta genérica para usuarios
    return jsonify({
        'error': 'Error interno del servidor',
        'code': 'INTERNAL_ERROR'
    }), 500
```

4.3 Capa de Datos

Controles de seguridad para la persistencia de datos:

a) Integridad Referencial:
```sql
-- Definición de claves foráneas con restricciones
FOREIGN KEY (departamento_id) REFERENCES departamentos (id)
    ON DELETE RESTRICT 
    ON UPDATE CASCADE
```

b) Validaciones a Nivel de Base de Datos:
```sql
-- Restricciones de dominio
CHECK (estado IN ('Ocupado', 'Libre', 'Mantenimiento'))
CHECK (piso > 0)
CHECK (monto > 0)
```

c) Auditoría de Cambios:
```python
# Registro de auditoría para cambios críticos
def log_data_change(table, operation, old_data, new_data, user):
    audit_log = {
        'timestamp': datetime.now().isoformat(),
        'table': table,
        'operation': operation,
        'old_data': old_data,
        'new_data': new_data,
        'user': user,
        'ip_address': request.remote_addr
    }
    
    with open('audit.log', 'a') as f:
        f.write(json.dumps(audit_log) + '\n')
```

================================================================================

5. AMENAZAS Y CONTRAMEDIDAS

5.1 Matriz de Amenazas Identificadas

┌─────────────────────┬──────────────┬──────────────┬─────────────────────┐
│      AMENAZA        │ PROBABILIDAD │   IMPACTO    │    CONTRAMEDIDA     │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┤
│ Inyección SQL       │    Media     │     Alto     │ Consultas           │
│                     │              │              │ Parametrizadas      │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┤
│ Cross-Site          │    Media     │    Medio     │ Validación entrada  │
│ Scripting (XSS)     │              │              │ + CSP Headers       │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┤
│ Acceso no           │     Alta     │     Alto     │ Autenticación +     │
│ autorizado          │              │              │ Segmentación red    │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┤
│ Pérdida de datos    │    Baja      │     Alto     │ Respaldos           │
│                     │              │              │ automáticos         │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┤
│ Man-in-the-Middle   │    Media     │    Medio     │ TLS 1.3 +           │
│                     │              │              │ Certificate Pinning │
└─────────────────────┴──────────────┴──────────────┴─────────────────────┘

5.2 Implementación de Contramedidas

a) Protección contra Inyección SQL:
```python
# INCORRECTO - Vulnerable a inyección
query = f"SELECT * FROM users WHERE username = '{username}'"

# CORRECTO - Uso de parámetros
query = "SELECT * FROM users WHERE username = ?"
cursor.execute(query, (username,))
```

b) Prevención de XSS:
```python
from markupsafe import escape

# Escapar datos de usuario antes de mostrar
def safe_render(user_input):
    return escape(user_input)
```

c) Protección CSRF:
```python
# Implementación de tokens CSRF
import secrets

def generate_csrf_token():
    return secrets.token_hex(16)

@app.before_request
def csrf_protect():
    if request.method == "POST":
        token = session.pop('_csrf_token', None)
        if not token or token != request.form.get('_csrf_token'):
            abort(403)
```

================================================================================

6. MONITOREO Y AUDITORÍA

6.1 Sistema de Logs Centralizados

La arquitectura implementa un sistema de logs estructurados:

```python
import logging
import json
from datetime import datetime

class SecurityLogger:
    def __init__(self):
        self.logger = logging.getLogger('security')
        handler = logging.FileHandler('security.log')
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
    
    def log_access_attempt(self, user, endpoint, success):
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_type': 'access_attempt',
            'user': user,
            'endpoint': endpoint,
            'success': success,
            'ip_address': request.remote_addr,
            'user_agent': request.headers.get('User-Agent')
        }
        
        self.logger.info(json.dumps(log_entry))
    
    def log_data_modification(self, table, operation, record_id):
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_type': 'data_modification',
            'table': table,
            'operation': operation,
            'record_id': record_id,
            'user': session.get('user_id'),
            'ip_address': request.remote_addr
        }
        
        self.logger.warning(json.dumps(log_entry))
```

6.2 Métricas de Seguridad

Indicadores clave de rendimiento de seguridad:

- Intentos de acceso fallidos por hora
- Tiempo de respuesta de autenticación
- Número de violaciones de validación
- Volumen de tráfico por endpoint
- Errores de base de datos por tipo

6.3 Alertas Automatizadas

Sistema de alertas para eventos críticos:

```python
class SecurityAlertManager:
    def __init__(self):
        self.failed_attempts = {}
        self.alert_threshold = 5
        self.time_window = 300  # 5 minutos
    
    def check_brute_force(self, ip_address):
        current_time = time.time()
        
        if ip_address not in self.failed_attempts:
            self.failed_attempts[ip_address] = []
        
        # Limpiar intentos antiguos
        self.failed_attempts[ip_address] = [
            attempt for attempt in self.failed_attempts[ip_address]
            if current_time - attempt < self.time_window
        ]
        
        # Verificar si excede el umbral
        if len(self.failed_attempts[ip_address]) >= self.alert_threshold:
            self.send_security_alert(
                f"Posible ataque de fuerza bruta desde {ip_address}"
            )
            return True
        
        return False
```

================================================================================

7. CUMPLIMIENTO Y REGULACIONES

7.1 Marco Legal y Normativo

El sistema cumple con las siguientes regulaciones:

a) Ley de Protección de Datos Personales:
   - Consentimiento explícito para procesamiento de datos
   - Derecho de acceso, rectificación y eliminación
   - Notificación de brechas de seguridad

b) Estándares de Seguridad:
   - ISO 27001: Sistema de Gestión de Seguridad de la Información
   - NIST Cybersecurity Framework
   - OWASP Top 10 mitigaciones

7.2 Políticas de Privacidad

Implementación de controles de privacidad:

```python
class PrivacyManager:
    def anonymize_data(self, data, fields_to_anonymize):
        """Anonimizar datos sensibles para reportes"""
        anonymized = data.copy()
        
        for field in fields_to_anonymize:
            if field in anonymized:
                if field == 'telefono':
                    anonymized[field] = 'XXX-XXXX'
                elif field == 'nombre':
                    anonymized[field] = 'Usuario Anónimo'
        
        return anonymized
    
    def apply_data_retention(self):
        """Aplicar políticas de retención de datos"""
        retention_period = 2555  # 7 años en días
        cutoff_date = datetime.now() - timedelta(days=retention_period)
        
        # Archivar o eliminar datos antiguos
        cursor.execute(
            "DELETE FROM pagos WHERE fecha < ?",
            (cutoff_date.isoformat(),)
        )
```

================================================================================

8. PLAN DE RESPUESTA A INCIDENTES

8.1 Procedimientos de Respuesta

Protocolo estructurado para manejo de incidentes:

Fase 1: Detección y Análisis
- Monitoreo automático de logs
- Alertas en tiempo real
- Clasificación de severidad

Fase 2: Contención y Erradicación
- Aislamiento de sistemas comprometidos
- Análisis forense básico
- Implementación de contramedidas

Fase 3: Recuperación
- Restauración de servicios
- Validación de integridad
- Monitoreo incrementado

Fase 4: Lecciones Aprendidas
- Documentación del incidente
- Actualización de procedimientos
- Mejoras en controles

8.2 Contactos de Emergencia

- Administrador del Sistema: admin@edificio.local
- Equipo de Seguridad: security@edificio.local
- Soporte Técnico: support@edificio.local

================================================================================

9. ARQUITECTURA DE RESPALDOS Y RECUPERACIÓN

9.1 Estrategia de Respaldos

Implementación de respaldos multi-nivel:

```python
import shutil
import gzip
from datetime import datetime

class BackupManager:
    def __init__(self):
        self.backup_path = "backups/"
        self.retention_days = 30
    
    def create_full_backup(self):
        """Crear respaldo completo de la base de datos"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = f"{self.backup_path}edificio_full_{timestamp}.db"
        
        # Copiar archivo de base de datos
        shutil.copy2("edificio.db", backup_file)
        
        # Comprimir respaldo
        with open(backup_file, 'rb') as f_in:
            with gzip.open(f"{backup_file}.gz", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        
        # Eliminar archivo sin comprimir
        os.remove(backup_file)
        
        return f"{backup_file}.gz"
    
    def create_incremental_backup(self):
        """Crear respaldo incremental basado en logs"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Exportar cambios desde último respaldo
        changes = self.export_recent_changes()
        
        backup_file = f"{self.backup_path}edificio_inc_{timestamp}.json"
        with open(backup_file, 'w') as f:
            json.dump(changes, f, indent=2)
        
        return backup_file
```

9.2 Plan de Recuperación ante Desastres

Procedimientos para diferentes escenarios:

Escenario 1: Corrupción de Base de Datos
1. Detener servicios de aplicación
2. Restaurar desde respaldo más reciente
3. Aplicar logs de transacciones
4. Validar integridad de datos
5. Reiniciar servicios

Escenario 2: Compromiso de Seguridad
1. Aislamiento inmediato del sistema
2. Análisis forense
3. Restauración desde respaldo limpio
4. Implementación de parches de seguridad
5. Monitoreo incrementado

Escenario 3: Falla de Hardware
1. Activación de sistema de respaldo
2. Migración de servicios
3. Restauración de datos
4. Pruebas de funcionalidad
5. Comunicación a usuarios

================================================================================

10. MÉTRICAS Y INDICADORES DE SEGURIDAD

10.1 KPIs de Seguridad

Indicadores clave para monitoreo continuo:

a) Disponibilidad del Sistema:
   - Tiempo de actividad: >99.5%
   - Tiempo promedio de respuesta: <2 segundos
   - Tiempo de recuperación ante fallas: <15 minutos

b) Seguridad de Acceso:
   - Intentos de acceso fallidos: <1% del total
   - Tiempo de detección de anomalías: <5 minutos
   - Cobertura de logs: 100% de transacciones críticas

c) Integridad de Datos:
   - Validaciones exitosas: >99.9%
   - Respaldos exitosos: 100%
   - Verificaciones de integridad: diarias

10.2 Dashboard de Seguridad

Implementación de panel de monitoreo:

```python
class SecurityDashboard:
    def __init__(self):
        self.metrics = {}
    
    def get_security_metrics(self):
        """Obtener métricas de seguridad en tiempo real"""
        return {
            'active_sessions': self.count_active_sessions(),
            'failed_logins_24h': self.count_failed_logins(24),
            'system_health': self.check_system_health(),
            'last_backup': self.get_last_backup_time(),
            'security_alerts': self.get_recent_alerts(),
            'data_integrity': self.verify_data_integrity()
        }
    
    def generate_security_report(self):
        """Generar reporte de seguridad semanal"""
        metrics = self.get_security_metrics()
        
        report = {
            'report_date': datetime.now().isoformat(),
            'summary': {
                'total_transactions': metrics['total_transactions'],
                'security_incidents': metrics['security_incidents'],
                'system_availability': metrics['availability_percentage']
            },
            'recommendations': self.generate_recommendations(metrics)
        }
        
        return report
```

================================================================================

11. FUTURAS MEJORAS DE SEGURIDAD

11.1 Roadmap de Seguridad

Mejoras planificadas para próximas versiones:

Corto Plazo (3 meses):
- Implementación de autenticación multifactor (MFA)
- Cifrado de datos sensibles en base de datos
- Sistema de detección de intrusiones (IDS)

Mediano Plazo (6 meses):
- Implementación de Single Sign-On (SSO)
- Análisis de comportamiento de usuarios
- Automatización de respuesta a incidentes

Largo Plazo (12 meses):
- Migración a arquitectura de microservicios
- Implementación de Zero Trust Architecture
- Inteligencia artificial para detección de amenazas

11.2 Tecnologías Emergentes

Evaluación de tecnologías para mejoras futuras:

a) Blockchain para Auditoría:
   - Logs inmutables de transacciones críticas
   - Trazabilidad completa de cambios
   - Validación distribuida de integridad

b) Machine Learning para Seguridad:
   - Detección de anomalías en patrones de uso
   - Clasificación automática de amenazas
   - Predicción de riesgos de seguridad

c) Contenedores y Orquestación:
   - Aislamiento mejorado de aplicaciones
   - Escalabilidad automática
   - Actualizaciones de seguridad sin interrupción

================================================================================

12. CONCLUSIONES

12.1 Resumen de la Arquitectura

La arquitectura de seguridad implementada en el Sistema de Administración de Edificios representa un enfoque integral que combina las mejores prácticas de la industria con las necesidades específicas del dominio de administración inmobiliaria. La segmentación de red en tres capas distintas (presentación, aplicación y datos) proporciona múltiples líneas de defensa contra amenazas internas y externas.

12.2 Fortalezas del Sistema

Las principales fortalezas de la arquitectura incluyen:

- Segregación efectiva de responsabilidades entre capas
- Implementación robusta de validaciones en múltiples niveles
- Sistema comprensivo de logs y auditoría
- Controles de acceso granulares
- Plan estructurado de respuesta a incidentes
- Cumplimiento con estándares internacionales de seguridad

12.3 Áreas de Mejora Continua

La seguridad es un proceso continuo que requiere evaluación y mejora constante. Las áreas identificadas para mejora incluyen:

- Automatización adicional de procesos de seguridad
- Implementación de análisis predictivo de amenazas
- Mejora en la experiencia de usuario sin comprometer seguridad
- Integración con sistemas de seguridad física del edificio

12.4 Impacto en el Negocio

La implementación de esta arquitectura de seguridad proporciona beneficios tangibles:

- Protección de datos críticos de inquilinos y propietarios
- Cumplimiento regulatorio proactivo
- Reducción de riesgos operacionales
- Mejora en la confianza de los usuarios
- Base sólida para escalabilidad futura

================================================================================

REFERENCIAS

Stallings, W. (2017). Network Security Essentials: Applications and Standards (6th ed.). Pearson Education.

National Institute of Standards and Technology. (2018). Framework for Improving Critical Infrastructure Cybersecurity, Version 1.1. NIST.

Open Web Application Security Project. (2021). OWASP Top 10 - 2021: The Ten Most Critical Web Application Security Risks. OWASP Foundation.

International Organization for Standardization. (2013). ISO/IEC 27001:2013 Information technology — Security techniques — Information security management systems — Requirements. ISO.

Goodrich, M. T., & Tamassia, R. (2014). Introduction to Computer Security. Pearson Education.

Howard, M., & LeBlanc, D. (2003). Writing Secure Code (2nd ed.). Microsoft Press.

Viega, J., & McGraw, G. (2001). Building Secure Software: How to Avoid Security Problems the Right Way. Addison-Wesley Professional.

Anderson, R. (2020). Security Engineering: A Guide to Building Dependable Distributed Systems (3rd ed.). Wiley.

================================================================================

ANEXOS

Anexo A: Configuraciones de Firewall Detalladas
Anexo B: Scripts de Monitoreo y Alertas
Anexo C: Procedimientos de Respuesta a Incidentes
Anexo D: Checklist de Auditoría de Seguridad
Anexo E: Diagramas de Flujo de Datos
Anexo F: Matriz de Riesgos Completa

================================================================================

© 2025 Sistema de Administración de Edificio. Todos los derechos reservados.
Documento confidencial - Solo para uso interno y académico.
